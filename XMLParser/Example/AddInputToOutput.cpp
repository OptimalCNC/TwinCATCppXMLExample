///////////////////////////////////////////////////////////////////////////////
// AddInputToOutput.cpp
#include "TcPch.h"
#pragma hdrstop

#include "AddInputToOutput.h"
#include "ExampleVersion.h"
#include "tinyxml2.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CAddInputToOutput
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CAddInputToOutput
BEGIN_INTERFACE_MAP(CAddInputToOutput)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_IPERSIST_LIB(CAddInputToOutput, VID_Example, CID_ExampleCAddInputToOutput)
IMPLEMENT_ITCOMOBJECT(CAddInputToOutput)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CAddInputToOutput)
IMPLEMENT_ITCADI(CAddInputToOutput)
IMPLEMENT_ITCWATCHSOURCE(CAddInputToOutput)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CAddInputToOutput 
BEGIN_SETOBJPARA_MAP(CAddInputToOutput)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_AddInputToOutputDiff, m_Diff)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CAddInputToOutput 
BEGIN_GETOBJPARA_MAP(CAddInputToOutput)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_AddInputToOutputDiff, m_Diff)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CAddInputToOutput
BEGIN_OBJPARAWATCH_MAP(CAddInputToOutput)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CAddInputToOutput
BEGIN_OBJDATAAREA_MAP(CAddInputToOutput)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_AddInputToOutputInputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_AddInputToOutputOutputs, m_Outputs)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CAddInputToOutput::CAddInputToOutput()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	m_Diff = 0;
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
CAddInputToOutput::~CAddInputToOutput() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CAddInputToOutput)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CAddInputToOutput::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlAlways, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	m_Trace.Log(tlAlways, FNAMEA "Entering PREOP to SAFEOP - hr=0x%08x", hr);

	using namespace tinyxml2;
	constexpr int nMaxRead = 512;
	char xml[nMaxRead];

	hr = m_spSrv->TcCreateInstance(CID_TcFileAccess, IID_ITcFileAccess, (PPVOID)(&m_spFileAccess));
	m_Trace.Log(tlAlways, "TcCreateInstance Created - hr=0x%08x", hr);

	if (SUCCEEDED(hr)) {
		m_Trace.Log(tlAlways, FNAMEA "Changing state of TcFileAccess");
		ITComObjectPtr spFileAccessObj = m_spFileAccess;
		hr = spFileAccessObj->TcSetObjState(TCOM_STATE_PREOP, m_spSrv, pInitData);
		m_Trace.Log(tlAlways, FNAMEA "TcFileAccess state changed - hr=0x%08x", hr);

		UINT n_reads = ReadFile("%TC_RESOURCEPATH%XMLParser/Config.xml", xml, nMaxRead - 1);
		xml[n_reads] = '\0';
		
		if (n_reads >= nMaxRead - 1) {
			m_Trace.Log(tlError, "The configuration file has larger size than the preconfigured one %d!", nMaxRead);
			return S_FALSE;
		}
	}

	XMLDocument doc;
	doc.Parse(xml);

	XMLElement* valueElement = doc.FirstChildElement("DIFF")->FirstChildElement("VALUE");
	const char* value = valueElement->GetText();
	m_Diff = atoi(value);
	m_Trace.Log(tlAlways, "Parameter Diff set to %d", m_Diff);

	m_Trace.Log(tlAlways, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CAddInputToOutput::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization


	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CAddInputToOutput::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	// TODO: Add any additional deinitialization

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CAddInputToOutput::SetObjStateSP()
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlVerbose, FENTERA);

	if (m_spFileAccess != NULL)
	{
		ITComObjectPtr spFileAccessObj = m_spFileAccess;
		spFileAccessObj->TcSetObjState(TCOM_STATE_INIT, m_spSrv, NULL);
		spFileAccessObj = NULL;
		m_spFileAccess = NULL;
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CAddInputToOutput::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	// TODO: Replace the sample with your cyclic code
	m_Outputs.Value = m_Inputs.Value + m_Diff;

	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CAddInputToOutput::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CAddInputToOutput::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA );

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;

	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////////////
UINT CAddInputToOutput::ReadFile(PCCH szFileNameRead, char* contents, UINT max_read)
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlAlways, FENTERA "szFileNameRead=%s", szFileNameRead);
	
	UINT nRead = 0;
	if (contents)
	{
		TcFileHandle hFile = NULL;
		hr = m_spFileAccess->FileOpen(szFileNameRead, static_cast<TcFileAccessMode>(amBinary | amRead), &hFile);
		m_Trace.Log(tlVerbose, "FileOpen hFile ");
		if (SUCCEEDED(hr))
		{
			m_Trace.Log(tlVerbose, "FileRead hFile ");
			m_spFileAccess->FileRead(hFile, contents, max_read, &nRead);
			m_spFileAccess->FileClose(hFile);
		}
	}
	m_Trace.Log(tlAlways, FLEAVEA "total bytes read=%d", nRead);
	return nRead;
}

